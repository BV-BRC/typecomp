
#BEGIN_HEADER

use CDMI;

our $entity_field_defs = {
[% FOREACH entity IN entities -%]
    '[% entity.name %]' => {
	[% FOREACH fent IN entity.field_map -%]
	    '[% fent.name %]' => 1,
	[% END %]
    },
[% END %]
};

sub _init_instance
{
    my($self) = @_;
    $self->{db} = CDMI->new(dbhost => 'seed-db-read', sock => '', DBD => '/home/parrello/FIGdisk/dist/releases/current/WinBuild/KSaplingDBD.xml');
}

sub _get_entity
{
    my($self, $ctx, $tbl, $ids, $fields) = @_;

    my $valid_fields = $entity_field_defs->{$tbl};

    my $have_id;

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my @qfields;
    my @sfields;
    my @bad_fields;
    for my $field (@$fields)
    {
	$field =~ s/-/_/g;
	if (!$valid_fields->{$field})
	{
	    push(@bad_fields, $field);
	    next;
	}
		
	push(@sfields, $field);
	my $qfield = $q . $field . $q;
	$have_id = 1 if $field eq 'id';
	push(@qfields, $qfield);
    }

    if (@bad_fields)
    {
	die "The following fields are invalid in entity $tbl: @bad_fields";
    }

    if (!$have_id)
    {
	unshift(@sfields, 'id');
	unshift(@qfields, $q . 'id' . $q);
    }
    
    my $filter = "id IN (" . join(", ", map { '?' } @$ids) . ")";

    my $qstr = join(", ", @qfields);
    my $qry = "SELECT $qstr FROM $q$tbl$q WHERE $filter";

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
    }

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    print STDERR "$qry\n";
    $sth->execute(@$ids);
    my $out = $sth->fetchall_hashref('id');
    return $out;
}    

sub _all_entities
{
    my($self, $ctx, $tbl, $start, $count, $fields) = @_;

    my $valid_fields = $entity_field_defs->{$tbl};

    my $have_id;

    my $cdmi = $self->{db};
    my $q = $cdmi->{_dbh}->quote;

    my @qfields;
    my @sfields;
    my @bad_fields;
    for my $field (@$fields)
    {
	$field =~ s/-/_/g;
	if (!$valid_fields->{$field})
	{
	    push(@bad_fields, $field);
	    next;
	}
		
	push(@sfields, $field);
	my $qfield = $q . $field . $q;
	$have_id = 1 if $field eq 'id';
	push(@qfields, $qfield);
    }

    if (@bad_fields)
    {
	die "The following fields are invalid in entity $tbl: @bad_fields";
    }

    if (!$have_id)
    {
	unshift(@sfields, 'id');
	unshift(@qfields, $q . 'id' . $q);
    }
    
    my $qstr = join(", ", @qfields);

    my $attrs = {};
    my $dbk = $cdmi->{_dbh};
    my $limit;
    
    if ($dbk->dbms eq 'mysql')
    {
	$attrs->{mysql_use_result} = 1;
	$limit = "LIMIT $start, $count";
    }
    elsif ($dbk->dbms eq 'Pg')
    {
	$limit = "ORDER BY id LIMIT $count OFFSET $start";
    }

    my $qry = "SELECT $qstr FROM $q$tbl$q $limit";

    my $sth = $dbk->{_dbh}->prepare($qry, $attrs);
    
    print STDERR "$qry\n";
    $sth->execute();
    my $out = $sth->fetchall_hashref('id');
    return $out;
}    

#END_HEADER

[% FOREACH entity IN entities %]

sub get_entity_[% entity.name %]
{
    my($self, $ctx, $ids, $fields) = @_;

    my $return;
    #BEGIN get_entity_[% entity.name %]

    $return = $self->_get_entity($ctx, '[% entity.name %]', $ids, $fields);

    #END get_entity_[% entity.name %]
    return $return;
}

sub all_entities_[% entity.name %]
{
    my($self, $ctx, $start, $count, $fields) = @_;

    my $return;
    #BEGIN all_entities_[% entity.name %]

    $return = $self->_all_entities($ctx, '[% entity.name %]', $start, $count, $fields);

    #END all_entities_[% entity.name %]
    return $return;
}
[% END %]
