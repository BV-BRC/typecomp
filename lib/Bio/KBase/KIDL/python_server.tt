from wsgiref.simple_server import make_server
import pprint,sys
from getopt import getopt, GetoptError
from jsonrpcbase import JSONRPCService
from os import environ
from ConfigParser import ConfigParser

#TODO fix overwrite, handle impl exceptions properly (needs edit to jsonrpcbase)

#BEGIN IMPORT_BLOCK

#END IMPORT_BLOCK

DEPLOY = 'KB_DEPLOYMENT_CONFIG'
SERVICE = 'KB_SERVICE_NAME'

[% FOREACH module IN modules %]
'''

Module Name:
[% module.module_name %]

Module Description:
[% module.module_doc %]

'''
class [% module.impl_package_name %]:

    #BEGIN_HEADER
[% module.module_header %]
    #END_HEADER

    def __init__(self):
        config = getConfigs() #contains contents of config file in hash or 
                              #None if it couldn't be found
            
        # BEGIN_CONSTRUCTOR
        # END_CONSTRUCTOR
        pass

[% FOREACH method IN module.methods %]

[% SET paramlist = [];
   FOREACH p IN method.params;
       paramlist.push(p.name);
   END;
   SET retlist = [];
   FOREACH var IN method.returns;
       IF var.name == 'return';
           retlist.push('returnVal');
       ELSE;
           retlist.push(var.name);
       END;
   END -%]
    def [% method.name %](self,  [% paramlist.join(', ') %] ):
        ctx = dict() # TBD - fill in calling context info
[% IF method.ret_count > 0 %]
        # initialize return variables [% retlist.join(", ") %]
[% FOR return IN method.returns -%]
        [% IF return.name == 'return' %]
        returnVal = None
        [% ELSE %]
        [% return.name %] = None
        [% END -%]
[% END -%]
[% END -%]

        #BEGIN [% method.name %]
        #END [% method.name %]

        # Someday we will do some return variable validation here

[% IF method.ret_count > 0 %]
        # return the results
        return [ [% retlist.join(', ') %] ]
[% END -%]
[% END -%]
[% END -%]

def getConfigs():
    if DEPLOY not in environ or SERVICE not in environ:
        return None
    retconfig = {}
    config = ConfigParser()
    config.read(environ[DEPLOY])
    for nameval in config.items(environ[SERVICE]):
        retconfig[nameval[0]] = nameval[1]
    return retconfig

impl = [% module.impl_package_name %]()

def application( environ, start_response):

    try:
        body_size = int( environ.get('CONTENT_LENGTH',0))
    except (ValueError):
        body_size = 0

    # Bring in the JSON RPC handler
    rpc_service = JSONRPCService()

[% FOREACH method IN module.methods %]
    rpc_service.add( impl.[% method.name %],name='[% module.module_name %].[% method.name %]')
[% END -%]

    request_body = environ['wsgi.input'].read( body_size)
    try:
        rpc_result = rpc_service.call( request_body)
    except Exception, e:
        print "Error in rpc call: %s" % e

    #print 'The request method was %s\n' % environ['REQUEST_METHOD']
    #print 'The environment dictionary is:\n%s\n' % pprint.pformat( environ )
    print 'The request body was: %s' % request_body
    print 'The result from the method call is:\n%s\n' % pprint.pformat(rpc_result)

    if rpc_result:
        response_body = rpc_result
    else:
        response_body = ''

    status = "200 OK"

    response_headers = [ ('Content-Type', 'text/plain'),
                         ('Content-Length', str(len(response_body)))]
    start_response( status, response_headers)
    return [response_body]

if __name__ == "__main__":
    try:
        opts, args = getopt(sys.argv[1:], "", ["port=","host="])
    except GetoptError as err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        sys.exit(2)      
    port = 9999
    host = 'localhost'
    for o, a in opts:
        if o == '--port':
            port = int(a)
        elif o == '--host':
            host = a
            print "Host set to %s" % host
        else:
            assert False, "unhandled option"
    
    print "Listening on port %s" % port
    httpd = make_server( host, port, application)

    while True:
        httpd.handle_request()
