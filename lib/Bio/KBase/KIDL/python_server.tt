from wsgiref.simple_server import make_server
import pprint, sys
from getopt import getopt, GetoptError
from jsonrpcbase import JSONRPCService, InvalidParamsError, KeywordError,\
  JSONRPCError, log, ServerError, ParseError, InvalidRequestError
from os import environ
from ConfigParser import ConfigParser
import json
import traceback
[% IF authenticated -%]
import nexus
[% END -%]

#TODO fix overwrite

#BEGIN IMPORT_BLOCK

#END IMPORT_BLOCK

DEPLOY = 'KB_DEPLOYMENT_CONFIG'
SERVICE = 'KB_SERVICE_NAME'

[% FOREACH module IN modules %]
'''

Module Name:
[% module.module_name %]

Module Description:
[% module.module_doc %]

'''
class [% module.impl_package_name %]:

    #BEGIN_HEADER
[% module.module_header %]
    #END_HEADER

    def __init__(self):
        config = getConfigs() #contains contents of config file in hash or 
                              #None if it couldn't be found
            
        # BEGIN_CONSTRUCTOR
        # END_CONSTRUCTOR
        pass

[% FOREACH method IN module.methods %]

[% SET paramlist = [];
   FOREACH p IN method.params;
       paramlist.push(p.name);
   END;
   SET retlist = [];
   FOREACH var IN method.returns;
       IF var.name == 'return';
           retlist.push('returnVal');
       ELSE;
           retlist.push(var.name);
       END;
   END -%]
    def [% method.name %](self,  [% paramlist.join(', ') %] ):
[% IF method.ret_count > 0 %]
        # return variables are: [% retlist.join(", ") %]
[% END -%]
        #BEGIN [% method.name %]
        #END [% method.name %]

        # Someday we will do some return variable validation here

[% IF method.ret_count > 0 %]
        # return the results
        return [ [% retlist.join(', ') %] ]
[% END -%]
[% END -%]
[% END -%]

def getConfigs():
    if DEPLOY not in environ or SERVICE not in environ:
        return None
    retconfig = {}
    config = ConfigParser()
    config.read(environ[DEPLOY])
    for nameval in config.items(environ[SERVICE]):
        retconfig[nameval[0]] = nameval[1]
    return retconfig

impl = [% module.impl_package_name %]()

class JSONRPCServiceCustom(JSONRPCService):
  
    def _call_method(self, request):
        """Calls given method with given params and returns it value."""
        method = self.method_data[request['method']]['method']
        params = request['params']
        result = None
        try:
            if isinstance(params, list):
                # Does it have enough arguments?
                if len(params) < self._man_args(method):
                    raise InvalidParamsError('not enough arguments')
                # Does it have too many arguments?
                if not self._vargs(method) and len(params) > self._max_args(method):
                    raise InvalidParamsError('too many arguments')

                result = method(*params)
            elif isinstance(params, dict):
                # Do not accept keyword arguments if the jsonrpc version is not >=1.1.
                if request['jsonrpc'] < 11:
                    raise KeywordError

                result = method(**params)
            else: # No params
                result = method()
        except JSONRPCError:
            raise
        except Exception:
            log.exception('method %s threw an exception' % request['method'])
            # Exception was raised inside the method.
            newerr = ServerError()
            newerr.data = traceback.format_exc()
            raise newerr
        return result
      
    def call_py(self, jsondata):
        """
        Calls jsonrpc service's method and returns its return value in python object format or None if there is none.

        This method is same as call() except the return value is a python object instead of JSON string. This method
        is mainly only useful for debugging purposes.
        """
        try:
            rdata = json.loads(jsondata)
        except ValueError:
            raise ParseError

        # set some default values for error handling
        request = self._get_default_vals()

        if isinstance(rdata, dict) and rdata:
            # It's a single request.
            self._fill_request(request, rdata)
            respond = self._handle_request(request)

            # Don't respond to notifications
            if respond is None:
                return None

            return respond
        elif isinstance(rdata, list) and rdata:
            # It's a batch.
            requests = []
            responds = []

            for rdata_ in rdata:
                # set some default values for error handling
                request_ = self._get_default_vals()
                self._fill_request(request_, rdata_)
                requests.append(request_)

            for request_ in requests:
                respond = self._handle_request(request_)
                # Don't respond to notifications
                if respond is not None:
                    responds.append(respond)

            if responds:
                return responds

            # Nothing to respond.
            return None
        else:
            # empty dict, list or wrong type
            raise InvalidRequestError


class Application:
    # Wrap the wsgi handler in a class definition so that we can
    # do some initialization and avoid regenerating stuff over
    # and over

    def __init__(self):
        self.rpc_service = JSONRPCServiceCustom()
[% IF authenticated -%]
        self.method_authentication = dict()
[% END -%]
[% FOREACH module IN modules -%]
[%   FOREACH method IN module.methods -%]
        self.rpc_service.add( impl.[% method.name %],name='[% module.module_name %].[% method.name %]')
[%     IF authenticated -%]
        self.method_authentication[ '[% module.module_name %].[% method.name %]' ] = '[% method.authentication %]'
[%     END -%]
[%   END -%]
[% END -%]
        self.auth_client = nexus.Client( config = { 'server' : 'nexus.api.globusonline.org',
                                                    'verify_ssl' : False,
                                                    'client' : None,
                                                    'client_secret': None})


    def __call__( self, environ, start_response):
        # Context object, equivalent to the perl impl CallContext
        ctx = { 'client_ip' : environ.get('REMOTE_ADDR'),
                'user_id' : None,
                'authenticated' : None,
                'token' : None }

        try:
            body_size = int( environ.get('CONTENT_LENGTH',0))
        except (ValueError):
            body_size = 0

        request_body = environ['wsgi.input'].read( body_size)
        try:
[% IF authenticated -%]
            token = environ.get( 'HTTP_AUTHORIZATION')
            # parse out the method being requested and check if it
            # has an authentication requirement
            req = json.loads( request_body)
            auth_req = self.method_authentication.get(req['method'], "none")
            if auth_req != "none":
                if token is None and auth_req == 'required':
                    err = ServerError()
                    err.data = "Authentication required for [% module.module_name %] but no authentication header was passed"
                    raise err
                elif token is None and auth_req == 'optional':
                    pass
                else:
                    try:
                        user, clientid, nexus_host = self.auth_client.validate_token(token)
                        ctx['user_id'] = user
                        ctx['authenticated'] = 1
                        ctx['token'] = token
                    except Exception, e:
                        if auth_req == 'required':
                            err = ServerError()
                            err.data = "Token validation failed: %s" % e
                            raise err
[% END -%]
            rpc_result = self.rpc_service.call( request_body)
        except JSONRPCError as jre:
            status = '500 Internal Server Error'
            err = {'error': {'code': jre.code,
                             'name': jre.message,
                             'message': jre.data
                             }
                   }
            rpc_result = json.dumps(err)
        except Exception, e:
            status = '500 Internal Server Error'
            err = {'error': {'code': 0,
                             'name': 'Unexpected Server Error',
                             'message': traceback.format_exc()
                             }
                   }
            rpc_result = json.dumps(err)

            print "Error in rpc call: %s" % e
        else:
            status = '200 OK'

        #print 'The request method was %s\n' % environ['REQUEST_METHOD']
        #print 'The environment dictionary is:\n%s\n' % pprint.pformat( environ )
        print 'The request body was: %s' % request_body
        print 'The result from the method call is:\n%s\n' % pprint.pformat(rpc_result)

        if rpc_result:
            response_body = rpc_result
        else:
            response_body = ''

    #    status = "200 OK"

        response_headers = [ ('content-type', 'application/json'),
                             ('content-length', str(len(response_body)))]
        start_response( status, response_headers)
        return [response_body]

application = Application()

if __name__ == "__main__":
    try:
        opts, args = getopt(sys.argv[1:], "", ["port=","host="])
    except GetoptError as err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        sys.exit(2)      
    port = 9999
    host = 'localhost'
    for o, a in opts:
        if o == '--port':
            port = int(a)
        elif o == '--host':
            host = a
            print "Host set to %s" % host
        else:
            assert False, "unhandled option"
    
    print "Listening on port %s" % port
    httpd = make_server( host, port, application)

    while True:
        httpd.handle_request()
